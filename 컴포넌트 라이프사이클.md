# 컴포넌트 라이프사이클

![라이프사이클](![라이프사이클](https://user-images.githubusercontent.com/43857226/125634865-7499d502-f13d-45d4-9ae2-dab4e792784d.PNG)

컴포넌트 인스턴스가 생성되어 DOM상에 삽입될 때 다음 순서대로 호출한다.</br>


### 마운트

**contructor()**</br>
static getDerivedStateFromProps()</br>
**render()**</br>
**componentDidMount()**</br>
</br>

### 업데이트

props 또는 state가 변경되면 발생. 아래 메서드들은 컴포넌트가 다시 렌더링될 때 순서대로 호출된다.</br>
</br>
static getDerivedStateFromProps()</br>
shouldComponentUpdate()</br>
**render()**</br>
getSnapshotBeforeUpdate()</br>
**componentDidUpdate()**</br>
</br>

### 해제

컴포넌트가 dom에서 제거될 때 호출</br>

**componentWillUnmount()**</br>


## 자주사용되는 라이프사이클 메소드

### render

render()는 반드시 구현되어야 한다. 렌더를 호출하면 this.props, this.state의 값을 활용해
하나를 반환해야한다.
</br>
1. React 엘리먼트. </br>
2. 배열과 Fragment. render()를 통하여 여러 개의 엘리먼트</br>
3. Portal. 별도의 DOM 하위 트리에 자식 엘리먼트를 렌더링</br>
4. 문자열과 숫자.</br>
5. Boolean 또는 null.</br>
</br>
render()는 순수함수여야 한다. 컴포넌트 state를 변경하지 않으며 호출될 때 마다 동일한 결과를 리턴해야 한다.</br>
</br>

### constructor(props)

바딩딩하거나 state초기화 작업이 없다면 생성자를 구현하지 않아도 된다. </br>
React.Component를 상속한 컴포넌트의 생성자를 구현할 때 super(props)를 호출해야 한다.</br>
생성자는 두가지 목적이 있다.</br>
</br>
1. this.state에 객체를 할당</br>
2. 인스턴스에 이벤트 처리 메소드를 바인딩 (this.handleClick.bind(this))</br>


**생성자 내부에서 setState()를 호출하면 안된다.**

```javascript
constructor(props) {
  super(props);
  // 여기서 this.setState()를 호출하면 X
  this.state = { data: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

생성자 내부에서 사이드이펙트를 발생시키거나 작업을 수행해선 안된다. </br>
componentDidMount()에서 사용하자. </br>

**state에 props를 복사하지 말자 !!**

```javascript
constructor(props) {
 super(props);
 this.state = { color: props.color };
}
```

props를 변경하더라도 state에 반영되지 않는다. 이는 props의 갱신을 의도적으로 무시한다. </br>


### componentDidMount()

componentDidMount() 컴포넌트가 마운트 직후 즉, 트리에 삽입된 직후 호출된다.</br>
DOM노드가 있어야 하는 초기화 작업은 여기서 작성하면 안된다.</br>
서버에서 데이터를 불러와야 할 때 여기서 작성하자 . </br>
</br>
componentDidMount()에서 즉시 setState()호출은 추가적인 렌더링이 발생하므로 성능문제가 발생한다. </br>
대부분의 경우 생성자 메소드에서 state를 할당할 수 있다. 그러나 모달같은 방식을 작성할 때 유용할 수 있다. </br>


### componentDidUpdate()

componentDidUpdate()는 갱신이 일어난 직후 호출된다. 최초 렌더링에는 호출되지 않는다.</br>
컴포넌트가 갱신될 때 DOM을 조작하기 위해 활용하자. 또 이전 props를 비교할 때 필요하다.</br>
</br>

```javascript
componentDidUpdate(prevProps){
	if(this.props.data !== prevProps.data){
		axios.get("http://localhost:1234")
		.then(todo)
		.catch(console.err)
	}
}
```

componentDidUpdate()는 setState를 즉시 호출할 수 있지만 위 예시처럼 조건문을 감싸지 않으면 무한루프가 발생할 수 있다. </br>
또 추가적인 렌더링 작업을 하며 성능에 영향을 줄 수 있다.</br>
**상위 컴포넌트에서 내려온 props를 그대로 state에 저장하는것은 좋지 못하다.** props를 직접 사용하는 것이 좋다.</br>

### componentWillUnmount()

componentWillUnmount()는 컴포넌트가 마운트 해제되어 제거되기 직전에 호출된다.</br>
여기서 타이머 제거, 등등 정리가 필요한 작업을 모두 수행하자.</br>
컴포넌트는 다시 렌더링되지 않으므로 setState()를 호출하면 안된다.</br>
